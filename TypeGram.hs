module TypeGram where

-- Haskell module generated by the BNF converter

import AbsGram
import ErrM
import Data.Map
import Control.Monad
import TravGram

type Env = [Context]
type Sig = ([Type], Type)
data TypeJudg = VarTypeJudg Type | FunTypeJudg Sig
type Context = Map Ident TypeJudg

lookupVar :: Env -> Ident -> Err (Maybe Type)
lookupVar env x = do
	case env of
		[] -> return Nothing
		en:ens -> do
			u <- Ok (Data.Map.lookup x en)
			case u of
				Just (VarTypeJudg t) -> return (Just t)
				Just (FunTypeJudg sig) -> fail $ "identifier: " ++ 
					transIdent x ++
					" that is expected to be a variable is" ++
					" actually a function\n"
				Nothing -> lookupVar ens x

lookupFun :: Env -> Ident -> Err (Maybe ([Type], Type))
lookupFun env x = do
	case env of
		[] -> return Nothing
		en:ens -> do
			u <- Ok (Data.Map.lookup x en)
			case u of
				Just (VarTypeJudg t) -> fail $ "identifier: "  ++ 
					transIdent x ++
					" that is expected to be a function is " ++
					"actually a variable\n"
				Just (FunTypeJudg sig) -> return (Just sig) 
				Nothing -> lookupFun ens x

updateVar :: Env -> Ident -> Type -> Err Env
updateVar env id typ = case env of
	[] -> Ok ((insert id (VarTypeJudg typ) empty):[])
	env:envs -> do
		u <- Ok (Data.Map.lookup id env)
		case u of
			Nothing -> return ((insert id (VarTypeJudg typ) env):envs)
			Just _ -> fail $ "identifier: " ++ transIdent id ++
				" is already defined in current context\n"

updateFun :: Env -> Ident -> ([Type], Type) -> Err Env
updateFun env id sig = case env of
	[] -> Ok ((insert id (FunTypeJudg sig) empty):[])
	env:envs ->  do
		u <- Ok (Data.Map.lookup id env)
		case u of
			Nothing -> Ok ((insert id (FunTypeJudg sig) env):envs)
			Just _ -> Bad $ "identifier: " ++ transIdent id ++
				" is already defined in current context\n"

newBlock :: Env -> Env
newBlock env = empty:env

emptyEnv :: Env
emptyEnv = [empty]

isAssignable :: Exp -> Bool
isAssignable e = case e of
	EArr _ _ -> True
	EVar _ -> True
	EDeref _ -> True
	EParen exp -> isAssignable exp
	_ -> False

inferExp :: Env -> Exp -> Err Type
inferExp env x = case x of
	EInt _ -> return TInt
	EDouble _ -> return TDouble
	EStr _ -> return TStr 
	EChar _ -> return TChar
	ETrue -> return TBool
	EFalse -> return TBool

	EVar id -> do
		u <- lookupVar env id
		case u of
			Just m -> return m
			Nothing -> fail $ "unknown identifier: "
				++ transIdent id ++ "\n"

	EArr exp sub -> do
		checkExp env TInt sub
		t <- inferExp env exp
		case t of
			TArray typ -> return typ
			_ -> fail $ "cannot apply subscript operator to" ++ 
				"expression: \n" ++ 
				"\t- " ++ transExp exp ++ "\n"
	
	EEql exp1 exp2 ->
		inferOrd env exp1 exp2 "=="	

	ELt exp1 exp2 ->
		inferOrd env exp1 exp2 "<"	

	EGt exp1 exp2 ->
		inferOrd env exp1 exp2 ">"	

	EAdd exp1 exp2 ->
		inferAdd env exp1 exp2 "+"

	ESub exp1 exp2 ->
		inferAdd env exp1 exp2 "-"

	EMul exp1 exp2 ->
		inferMul env exp1 exp2 "*"

	EDiv exp1 exp2 ->
		inferMul env exp1 exp2 "/"

	ENot exp -> do 
		checkExp env TBool exp
		return TBool

	EDeref exp -> do 
		u <- inferExp env exp
		case u of
			TPtr u -> Ok u
			_ -> fail $ "cannot dereference expression: " ++ "\n" ++
				"\t- " ++ transExp exp ++ " : " ++ transType u ++ "\n"

	ERefer exp -> do
		u <- inferExp env exp
		case u of
			TMem u -> fail $ "cannot take the memory address " ++
				"of expression: " ++ "\n" ++
				"\t- " ++ transExp exp ++ " : " ++ transType u ++ "\n"
			_ -> if isAssignable exp then 
					Ok (TMem u) 
				 else fail $ "cannot take the memory address " ++
					"of expression: " ++ "\n" ++
					"\t- " ++ transExp exp ++ " : " ++ transType u ++ "\n"

	EParen exp -> do
		inferExp env exp
	
	ECall id exps -> do
		u <- lookupFun env id
		case u of
			Just (typs, retv) ->
				if (length typs == length exps) then do
					checkFunArg env exps typs id
					return retv
				else fail $ "function: " ++ transIdent id ++ "\n" ++
					"\t has expected arity: " ++ show (length typs) ++
					"but is invoked with: " ++ show (length exps) ++
					"formal parameters\n"
			Nothing -> fail $ "unknown identifier: " ++
				transIdent id ++ "\n"

checkFunArg :: Env -> [Exp] -> [Type] -> Ident -> Err ()
checkFunArg env exps typs id = do
	case typs of
		t:ts -> do
			checkExp env t (head exps)
			checkFunArg env (tail exps) (tail typs) id
			
		[] -> Ok ()

inferOrd :: Env -> Exp -> Exp -> String -> Err Type
inferOrd env exp1 exp2 opName = do
	typ1 <- inferExp env exp1
	typ2 <- inferExp env exp2
	case typ1 of
		TPtr _ ->
			case typ2 of
				TPtr _ -> return TBool
				_ -> fail $ "comparison " ++ opName ++
					" between incompatible expressions: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n"
					++ "\t- " ++ transExp exp2 ++ " : " 
						++ transType typ2 ++ "\n"
		_ ->
			if (typ1 == typ2) then return TBool else
				fail  $ "comparison " ++ opName ++
					" between incompatible expressions: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n"
					++ "\t- " ++ transExp exp2 ++ " : " 
						++ transType typ2 ++ "\n"

inferAdd :: Env -> Exp -> Exp -> String -> Err Type
inferAdd env exp1 exp2 opName =  do
	typ1 <- inferExp env exp1
	typ2 <- inferExp env exp2
	case typ1 of
		TPtr t ->
			case typ2 of
				TInt -> return (TPtr t)
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"
		TInt ->
			case typ2 of
				TInt -> return TInt
				TDouble -> return TDouble
				TStr -> return TStr
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"

		TDouble ->
			case typ2 of
				TInt -> return TDouble
				TDouble -> return TDouble
				TStr -> return TStr
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"

		TStr ->
			case typ2 of
				TInt -> return TStr
				TDouble -> return TStr
				TStr -> return TStr
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"
				

inferMul :: Env -> Exp -> Exp -> String -> Err Type
inferMul env exp1 exp2 opName =  do
	typ1 <- inferExp env exp1
	typ2 <- inferExp env exp2
	case typ1 of
		TInt ->
			case typ2 of
				TInt -> return TInt
				TDouble -> return TDouble
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"

		TDouble ->
			case typ2 of
				TInt -> return TDouble
				TDouble -> return TDouble
				_ -> fail $ "operator: " ++ opName ++
					" has incompatible operands: \n" ++
					"\t- " ++ transExp exp1 ++ " : "
						++ transType typ1 ++ "\n" ++
					"\t- " ++ transExp exp2 ++ " : "
						++ transType typ2 ++ "\n"

checkExp :: Env -> Type -> Exp -> Err () 
checkExp env typ exp = do
	typ2 <- inferExp env exp

	if (typ2 == typ) then return () 
		else
			fail $ "cannot match expression: \n" 
				++ "\t- " ++ transExp exp ++ " : " ++ transType typ ++ "\n"
				++ "with its expected type: " ++ transType typ2


checkAss :: Env -> Ass -> Err ()
checkAss env (DAss lexp rexp) =
	if (isAssignable lexp) then do
		ltype <- inferExp env lexp
		rtype <- inferExp env rexp
		case ltype of
			TPtr t -> case rtype of
				TPtr u -> if (u == t) then return ()
					else fail $ "cannot match expression: \n" 
					++ "\t- " ++ transExp rexp ++ " : " ++
					transType rtype ++ "\n"
					++ "with its expected type: " ++ transType ltype
					++ "\n"
				TMem u -> if (u == t) then return ()
					else fail $ "cannot match expression: \n" 
					++ "\t- " ++ transExp rexp ++ " : " ++
					transType rtype ++ "\n"
					++ "with its expected type: " ++ transType ltype
					++ "\n"
				_ -> fail $ "cannot match expression: \n" 
					++ "\t- " ++ transExp rexp ++ " : " ++ 
					transType rtype ++ "\n"
					++ "with its expected type: " ++ transType ltype
					++ "\n"

			_ -> if (ltype == rtype) then return () 
					else
						fail $ "cannot match expression: \n" 
							++ "\t- " ++ transExp rexp ++ " : " ++ 
							transType ltype ++ "\n"
							++ "with its expected type: " 
							++ transType rtype ++ "\n"
		else
			Bad $ "expression: \n" 
			++ "\t- " ++ transExp lexp ++ "\n" ++
			" is not assignable\n" 	
	

checkStm :: Env -> Stm -> Err Env
checkStm env x = case x of

		SNop -> do
			return env

		SExp exp -> do
			inferExp env exp
			return env

		SBlock stms -> do
			checkStmLst (newBlock env) stms
			return env

		SDecl (Dec id typ) ->
			updateVar env id typ

		SAss ass -> do
			checkAss env ass 
			return env

		SWhileA ass exp stms -> do
			checkAss env ass
			checkExp env TBool exp
			checkStmLst env stms
			return env

		SWhile exp stms -> do
			checkExp env TBool exp
			checkStmLst env stms
			return env

		SCond exp stms -> do
			checkExp env TBool exp
			checkStmLst env stms
			return env

		SCondEl exp stmt stmf -> do
			checkExp env TBool exp
			checkStmLst env stmt
			checkStmLst env stmf
			return env

		SWInt exp -> do
			checkExp env TInt exp
			return env

		SRInt -> do
			return env

		SWDou exp -> do
			checkExp env TDouble exp
			return env

		SRDou -> do
			return env

		SWStr exp -> do
			checkExp env TStr exp
			return env

		SRStr -> do
			return env

		SReturn exp -> do
			u <- lookupVar env (Ident "return")
			case u of
				Just typ -> do
					checkExp env typ exp
					return env
				Nothing -> fail $ "nothing to return the control to\n"

		SFunc (Fun id pdecls rtyp stms) -> do
			u <- makeFncCntxSwitch env id pdecls rtyp
			checkStmLst u stms
			v <- insertFunDeclInCtxt env id pdecls rtyp
			return v

typeOfPDecl :: PDecl -> Type
typeOfPDecl (PDec p t) = t

insertFunDeclInCtxt :: Env -> Ident -> [PDecl] -> Type -> Err Env
insertFunDeclInCtxt env id pdecls rtyp = do
	u <- updateFun env id ((Prelude.map typeOfPDecl pdecls), rtyp)
	return u

insertPDeclContext :: Env -> PDecl -> Err Env
insertPDeclContext env (PDec p t) =
	case p of
		PVal id -> updateVar env id t
		PValres id -> updateVar env id t
		PName id -> updateVar env id t
		PRef id -> updateVar env id t
		PImpl id -> updateVar env id t	

makeFncCntxSwitch :: Env -> Ident -> [PDecl] -> Type -> Err Env
makeFncCntxSwitch env id pdecls rtyp = do
	u <- foldM insertPDeclContext (newBlock env) pdecls
	v <- updateVar u (Ident "return") rtyp
	w <- insertFunDeclInCtxt v id pdecls rtyp
	return w

checkStmLst :: Env -> [Stm] -> Err Env
checkStmLst env stms = case stms of
	[] -> return env
	x:xs -> do
		new_env <- checkStm env x 
		checkStmLst new_env xs

checkPrg :: Program -> Err Env 
checkPrg (Prog stms) = checkStmLst emptyEnv stms
